# CS305 Chapter 2

Application Layer: 应用层

## Part 1. Principles of network applications

### 1.1 网络应用的两种体系结构

#### 结构1：Client-server

我个人理解，这是一个中央集中式的体系结构。主要由中心服务器和若干分散的客户端组成。

服务器：
- 持久运行
- IP地址不变
- 经常是数据中心

客户端：
- 需要通过服务器完成和其他客户端的交互
- IP地址有可能是变化的，且有可能会间断性地断开
- 不能直接和其他客户端通信

这种网络体系结构的应用层协议有HTTP，IMAP和FTP等等。

#### 结构2：P2P

我个人理解，这是一个分布式的体系结构，每个主机既是客户端，又是服务器。

主要有以下特点：
- 无中央持久运行的服务器
- 主机之间可以任意进行直接的通讯
- 主机之间可以向其他主机请求或贡献资源
- 主机IP地址有可能会变化，且会经常性断开

这种网络体系结构的应用层协议有P2P file sharing。

### 1.2 进程通讯与Socket

#### 基本概念

进程：主机上运行的程序

- 同一主机上，进程间的通讯交由OS完成。
- 不同主机上，进程间的通讯需要通过网络交换信息。
- 客户端与服务器
  - 客户端：初始化连接的进程
  - 服务端：等待连接的进程
- 进程通过网络收发消息的途径是Socket

![image](https://user-images.githubusercontent.com/64548919/213470164-77f10a4a-e6d3-4d8c-9cce-f9533a1663af.png)

#### 进程定位

进程是在主机上运行的程序，因此它具有的信息是主机的IP和该程序占用的端口号。（这从另一个角度说明，仅仅使用IP地址定位进程是不合理的，因为一个主机上可以运行很多个进程）

首先通过IP地址定位到具体的主机，然后通过端口号定位到相应的进程。

**端口号**
- HTTP: 80
- Mail: 25

### 1.3 应用层协议功能

应用层协议主要的功能是：
- 确定消息种类（比如说井字棋应用中，如何确定是建立连接与下棋步骤？）
- 确定消息语法规则（比如说井字棋应用中，如何确定下棋消息的语法规则？）
- 确定消息语义（比如说井字棋应用中，如果确定下棋消息的具体位置？）
- 确定消息的收发规则（比如说井字棋应用中，如何确定下棋的先后手？）
- ......

其中，与应用层对接的传输层必须要考虑以下四个重要的特性：
- 传输的数据完整性
- 传输过程的时延
- 传输过程的吞吐量
- 传输过程的数据安全性

传输层有两个主流的协议：TCP协议和UDP协议。我个人理解，TCP协议就像两个人用纸互相写字通讯，传输是100%可靠的但比较慢，而UDP协议就像一个人拿着一个大喇叭向对方进行大吼，不管对方有没有听到，比较快但不一定可靠。

下面将TCP协议和UDP协议进行进一步详细的比较。

- TCP: Transmission Control Protocol
- UDP: User Datagram Protocol

|              | TCP        | UDP                |
|--------------|------------|--------------------|
| 可靠传输     | 1          | 0                  |
| 流量控制     | 1          | 0                  |
| 拥塞控制     | 1          | 0                  |
| 面向连接     | 1          | 0                  |
| 计时机制     | 0          | 0                  |
| 最小吞吐量   | 0          | 0                  |
| 安全         | 0          | 0                  |
| 传输速度     | 慢         | 快                 |
| 系统资源占用 | 大         | 小                 |
| 使用场景     | QQ文件传输 | 微信电话，QQ音视频 |

（注：1表示有该功能，0表示没有）

然后还需要记一下应用层协议与传输层协议的对应关系。

| 应用程序     | 应用层协议 | 传输层协议 |
|--------------|------------|------------|
| 文件上传下载 | FTP        | TCP        |
| 电子邮件     | SMTP       | TCP        |
| Web文档      | HTTP 1.1   | TCP        |
| 网络电话     | SIP, RTP   | TCP/UDP    |
| 音视频流媒体 | HTTP       | TCP        |
| 交互式游戏   | WOW, FPS   | TCP/UDP    |

## Part 2. Web and HTTP

HTTP: Hypertext transfer protocol

### 2.1 HTTP Overview

这是一个中央集中式的客户端-服务器模型。周围的若干客户端是请求和展示网络资源的浏览器，中央的服务器是针对请求返回数据的Web服务器。

![image](https://user-images.githubusercontent.com/64548919/213479039-68c92840-43eb-4419-9865-9cb06aac1e43.png)

HTTP使用TCP作为传输层协议，传输流程如下：
- 客户端在80端口发起TCP连接请求
- 服务器接收来自客户端的TCP连接请求
- 客户端和服务器之间交换消息（1.0版本中只能发一条消息，资源浪费很大，后来的版本有所改善）
- TCP连接关闭

HTTP是无状态，无连接的。这样的设计是为了节约资源，不想关心以前的连接状态。

Q: 应用层的HTTP协议是无连接的，但它基于的传输层TCP协议是面向连接的。这点如何解释呢？

A: 这点是将”连接”一词做了混淆。HTTP是应用层的抽象，指的是HTTP本身的行为是不会关注之前的连接状态的，也不会管HTTP协议下的”连接”，和下层传输层使用的协议无关（HTTP底层也可以不用TCP协议，可以换成UDP）。

HTTP协议和下层的传输层协议已经解耦，因此TCP传输层的持久连接行为不会受到HTTP协议无连接的影响。

### 2.2 两种HTTP连接

#### 非持久HTTP连接（1.0）

这种实现非常朴素，也非常浪费连接资源，因为要频繁地建立和关闭连接。

- 打开TCP连接
- 通过该连接，至多发送一个数据包
- 关闭TCP连接

【RTT定义】对于一个数据包，从客户端发送到服务器再回来所需要的时间。

因此请求一个HTTP对象就需要2个RTT和传输时间
- RTT建立TCP连接
- RTT用于请求和接受对象
- 请求HTTP对象所需要的传输时间

（如果算整个时间的话，还需要加上2个RTT用于TCP连接的四次挥手）

#### 持久HTTP连接（1.1）

这种实现可以将连接的建立和关闭的代价均摊到多个请求里。

- 打开和服务器的TCP连接
- 通过该连接，发送多个请求并得到响应
- 关闭TCP连接

这样持久化的连接就可以节约TCP连接建立和关闭的时间，平均每个对象所需要的时间仅为1个RTT和传输时间而已。

### 2.3 HTTP请求报文

HTTP有两种请求报文：request和response

**【重要】** 它的数据报文编码是**ASCII**，是人类可读的ABCD等等等等。

![image](https://user-images.githubusercontent.com/64548919/213487423-484888ec-fd4d-4c60-b832-1ef0704c5313.png)

HTTP有几种请求的方法。

- POST：向制定资源提交要被处理的数据
- GET：从指定资源请求数据（结尾有`?`的请求）
- HEAD：与GET类似，但不返回消息体（主要用于测试HTTP连接的有效性）
- PUT：也是上传资源，但对于已有的资源会执行覆盖操作

HTTP有几种响应状态码。

- 200：OK。正常响应
- 301：Moved Permanently。资源永久被移动
- 400：Bad Request。服务器没法理解这个请求。
- 404：Not Found。服务器没这个请求资源。
- 505：HTTP Version Not Supported。服务器不支持请求中所用的 HTTP 协议版本。

### 2.4 HTTP cookie

之前说过HTTP本身是无状态的，但有时候又需要记录状态信息。这时候就可以通过cookie来实现这个功能。

Cookie的功能：
- 鉴权
- 用户推荐
- 用户会话状态

保持状态的两种方法：
1. 客户端/服务器记录用户的当前状态（如井字棋的服务器体系）
2. 使用cookie，带有用户状态的HTTP消息

### 2.5 Web Proxy

Web代理服务器的功能和计算机组成原理里的cache作用是类似的，主要功能是满足用户的请求，并且不需要每次都请求中央服务器，从而大大节约用户的请求时间。


## Part 3. E-mail, SMTP, IMAP

## Part 4. The Domain Name System DNS

## Part 5. P2P applications

## Part 6. Video streaming and content distribution networks

## Part 7. Socket programming with UDP and TCP